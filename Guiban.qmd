---
title: "Guiban"
author: "Marilys Guiban"
format: html
---

```{r}
library(here)
library(dplyr)
library(tidyr)
library(vroom)
library(readr)

here::i_am("eval-grades.Rproj")
```

### Question 1

```{r}
courses <- vroom(here("data", "courses.csv"))
```

### Question 2

```{r}
# Load the necessary library for table formatting
library(knitr) 
library(dplyr)

# 1. Prepare the data: Sort and rename columns
courses |>
  arrange(course) |> 
  rename(
    "course name" = course,
    "identifier" = course_id,
    "module" = module,
    "Number of Exams" = nb_grades
  ) |>
  kable(
    caption = "Course Descriptions and Exam Counts",
    align = "l"
  )
```

### Question 3

```{r}
students <- vroom(here("data", "students.csv"))
students |>
  mutate(
    id = as.integer(id),          # recommended in the instructions
    group = as.factor(group),     # recommended in the instructions
    birth_date = as.Date(birth_date),  # must be Date
    sex = as.factor(sex)               # must be factor
  )
```

```{r}
str(students)

```

### Question 4

```{r}
gradenaive <- read.csv(here("data", "grades.csv"))


grades <- read_delim(
  here("data", "grades.csv"),
  delim = ":",    # Correct separator
  na = "$",       # Convert $ to NA
  col_types = cols(
    id = col_integer(),
    course_id = col_integer(),
    grade = col_double()
  )
)

# Preview the first rows (optional but recommended)
head(grades)
```

### Question 5

```{r}
students_factor <- read_delim(here("data", "students.csv"),
  col_types = cols(
     sex = col_factor()
  )
)
```

```{r}
str(students_factor)
```

Now that sex is well-encoded let's compute the graphical representation :

```{r}
library(ggplot2)
students <- students |> 
  mutate(group = as.factor(group))

ggplot(students, aes(x = group)) +
  geom_bar(fill = "#1f77b4") +           # bar plot
  labs(
    title = "Number of Students per Group",
    x = "Group",
    y = "Number of Students"
  ) +
  theme_minimal(base_size = 14) 
```

### Question 6

```{r}
ggplot(students, aes(x = group, fill = sex)) +
  geom_bar() +
  labs(
    title = "Gender Balance per Group",
    x = "Group",
    y = "Number of Students",
    fill = "Sex"
  ) +
  theme_minimal(base_size = 14)
```

### Question 7

```{r}
students <- students |>
  mutate(age = as.integer(floor((Sys.Date() - birth_date)/365.25)))

ggplot(students, aes(x = age)) +
  geom_histogram(binwidth = 1, fill = "#1f77b4", color = "black") +
  labs(
    title = "Distribution of Student Ages",
    x = "Age (years)",
    y = "Number of Students"
  ) +
  theme_minimal(base_size = 14)
```

### Question 8

```{r}
students <- students |>
  mutate(age_years = as.numeric(Sys.Date() - birth_date) / 365.25)

median_age_group <- students |>
  group_by(group) |>
  summarise(median_age = round(median(age_years), 1), .groups = "drop")

median_age_group |> kable(
  caption = "Median Age of Students per Group (in years, with decimals)",
  col.names = c("Group", "Median Age (years)")
)
```

### Question 9

```{r}
students |>
  group_by(group) |>
  filter(age == max(age)) |>
  select(ID = id, Sex = sex, Age = age) |>  # rename columns directly
  ungroup() |>
  arrange(desc(Age)) |> 
  print()
```

## Simple grade analysis

### Question 10

Before doing these questions, it seems more relevant to join the two files together :

```{r}
grades_students <- grades |>
  filter(!is.na(grade)) |>             # remove missing grades
  inner_join(students, by = "id") 
```

```{r}
n_grades <- grades_students |>
  summarise(total = n()) |>
  pull(total)

# In order to print the sentence we do : 
cat("The data set contains", n_grades, "grades.\n")
```

### Question 11

```{r}
# Compute average grade per group for Cryptography
avg_crypto <- grades_students |>
  left_join(courses, by = "course_id") |>      # get course names
  filter(course == "Cryptography and Codebreaking") |>
  group_by(group) |>
  summarise(avg_grade = mean(grade, na.rm = TRUE), .groups = "drop")

ggplot(avg_crypto, aes(x = as.factor(group), y = avg_grade, fill = as.factor(group))) +
  geom_col() + 
  labs(
    title = "Average Grade in Cryptography and Codebreaking by Group",
    x = "Group",
    y = "Average Grade",
    fill = "Group"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none")

```

### Question 12

In this question we compare the distribution of all the grades per module :

```{r}
library(dplyr)
library(ggplot2)

grades_modules <- grades_students |>
  left_join(courses, by = "course_id") |>
  filter(!is.na(grade))  # garder toutes les notes

# Boxplot avec facet_wrap pour comparer Module 1 et Module 2
ggplot(grades_modules, aes(x = as.factor(group), y = grade, fill = as.factor(group))) +
  geom_boxplot() +
  scale_y_continuous(limits = c(0, 20)) +  # axe 0-20 pour toutes les notes
  labs(
    title = "Grade Distribution by Module and Group",
    x = "Group",
    y = "Grade",
    fill = "Group"
  ) +
  facet_wrap(~ module, nrow = 1) +  # un facet par module, côte à côte
  theme_minimal(base_size = 14) +
  theme(legend.position = "none")

```

### Question 13

```{r}
grades_per_student <- grades_students |>
  filter(!is.na(grade)) |>              # remove missing grades
  group_by(id, group, sex) |>
  summarise(n_grades = n(), .groups = "drop")

# Show an extract of the resulting data frame (first 10 rows)
head(grades_per_student, 10)

# Compute min, max, mean, median
grades_summary <- grades_per_student |>
  summarise(
    min = min(n_grades),
    max = max(n_grades),
    mean = mean(n_grades),
    median = median(n_grades)
  ) |> 
  knitr::kable()
```

### Question 14

```{r}
grades_by_sex <- grades_per_student |>
  group_by(sex) |>
  summarise(total_grades = sum(n_grades), .groups = "drop")

# Bar plot
ggplot(grades_by_sex, aes(x = sex, y = total_grades, fill = sex)) +
  geom_col() +
  labs(
    title = "Total Number of Grades by Sex",
    x = "Sex",
    y = "Total Grades",
    fill = "Sex"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none")
```

### Question 15

```{r}
library(dplyr)
library(knitr)

# 1. Identifier l'ID du cours "Alchemy and Chemical Engineering" (Course ID 4 dans l'exemple)
course_alchemy_id <- courses |>
  filter(course == "Alchemy and Chemical Engineering") |>
  pull(course_id)

# 2. Créer le data frame 'grades_alchemy'
grades_alchemy <- grades |>
  # Filtrer uniquement les notes pour le cours d'Alchimie
  filter(course_id == course_alchemy_id) |>
  # Joindre avec les étudiants pour obtenir le groupe
  left_join(students |> select(id, group), by = "id") |>
  # Compter le nombre de notes par étudiant
  group_by(id, group) |>
  summarise(
    nb_grades_alchemy = n(),
    .groups = "drop"
  )

grades_alchemy |>
  slice_head(n = 5) |>
  kable(
    caption = "Extrait du nombre de notes en Alchemy and Chemical Engineering par étudiant"
  )
```

### Question 16

```{r}
# 1. Calculer la distribution (compter le nombre d'étudiants par nombre de notes)
distribution_grades_alchemy <- grades_alchemy |>
  group_by(nb_grades_alchemy) |>
  summarise(
    n_students = n(),
    .groups = "drop"
  ) |>
  # Convertir le nombre de notes en facteur pour un axe X catégoriel propre
  mutate(
    nb_grades_alchemy = as.factor(nb_grades_alchemy)
  )

# 2. Représentation graphique (Diagramme en colonnes)
ggplot(distribution_grades_alchemy, aes(x = nb_grades_alchemy, y = n_students)) +
  geom_col(fill = "#FF9933") +
  geom_text(aes(label = n_students), vjust = -0.5, size = 4) +
  labs(
    title = "Distribution du Nombre de Notes par Étudiant en Alchemy and Chemical Engineering",
    x = "Nombre de Notes Obtenues",
    y = "Nombre d'Étudiants"
  ) +
  theme_minimal(base_size = 14) +
  scale_y_continuous(limits = c(0, max(distribution_grades_alchemy$n_students) * 1.1))
```

### Question 17

```{r}
ggplot(grades_alchemy, aes(x = as.factor(group), y = nb_grades_alchemy, fill = as.factor(group))) +
  geom_boxplot() +
  labs(
    title = "Nombre de Notes en Alchemy and Chemical Engineering par Groupe",
    x = "Groupe d'Étudiants",
    y = "Nombre de Notes Obtenues"
  ) +
  theme_minimal() +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1))
```

Here it seems that the lowest grade differ but the mean does not seem do differ between each group.

### Question 18 
```{r}
# 1. Préparer les données en ajoutant la variable 'sex'
# Assurez-vous que le data frame 'students' est disponible
grades_alchemy_sex <- grades_alchemy |>
  # Joindre par 'id' pour récupérer la colonne 'sex'
  left_join(students |> select(id, sex), by = "id")

# 2. Représentation graphique : Boxplot Groupé par Sexe
ggplot(grades_alchemy_sex, aes(x = as.factor(group), y = nb_grades_alchemy, fill = sex)) +
  # Boxplot avec position_dodge pour séparer les F et les M au sein de chaque groupe X
  geom_boxplot(position = position_dodge(width = 0.8), alpha = 0.7) +
  labs(
    title = "Nombre de Notes en Alchemy and Chemical Engineering : Analyse Groupée par Sexe",
    x = "Groupe d'Étudiants",
    y = "Nombre de Notes Obtenues",
    fill = "Sexe" # La légende est essentielle ici
  ) +
  # Assurer que l'axe Y montre les valeurs entières des notes
  scale_y_continuous(breaks = unique(grades_alchemy_sex$nb_grades_alchemy)) +
  theme_minimal() +
  # Rotation des étiquettes pour les 20 groupes
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
here it seems that the first and the last quartile of some groups are higher in some groups than u-in other. For instance the third quartile of group is higher. Further more we can note that there is no significant difference between men and women. Except for group fifteen where the median of the women is lower than the median of the men. 
Hence we can say that even though it is not that obvious there is a difference for the grades between men and women and by groups. There is a kind of dependency. 

### Question 19
```{r}
library(dplyr)
library(tidyr)
library(knitr)

avg_grades_per_course_student <- grades |>
  filter(!is.na(grade)) |>
  summarise(
    avg_grade = mean(grade, na.rm = TRUE),
    .by = c(id, course_id)
  ) |>
  # Joindre les noms de cours et le groupe de l'étudiant
  left_join(courses |> select(course_id, course), by = "course_id") |>
  left_join(students |> select(id, group), by = "id") |>
  select(id, group, course, avg_grade)
```

Let's use pivoting : 
```{r}
student_performance_wide <- avg_grades_per_course_student |>
  pivot_wider(
    id_cols = c(id, group),
    names_from = course,
    values_from = avg_grade
  )
student_performance_wide |>
  slice_head(n = 5) |>
  kable(
    caption = "Extrait de la Performance Moyenne par Étudiant (Toutes les matières incluses)",
    digits = 2)
```
### Question 20 
```{r}
library(ggplot2)
library(dplyr)

# 1. Calculer les moyennes générales pour les lignes de référence
avg_crypto <- mean(student_performance_wide$`Cryptography and Codebreaking`, na.rm = TRUE)
avg_fashion <- mean(student_performance_wide$`Fashion Design and Textile Innovation`, na.rm = TRUE)

# 2. Créer le graphique amélioré
ggplot(student_performance_wide, 
       aes(x = `Cryptography and Codebreaking`, 
           y = `Fashion Design and Textile Innovation`)) + 
  
  # Points en bleu uni
  geom_point(alpha = 0.7, size = 2, color = "#1f77b4") +
  
  # Ligne de régression
  geom_smooth(method = "lm", se = FALSE, color = "darkgrey", linetype = "dashed", linewidth = 0.5) +
  
  # Ligne de l'Average Grade pour Cryptography (verticale)
  geom_vline(xintercept = avg_crypto, color = "red", linetype = "solid", linewidth = 1) +
  
  # Ligne de l'Average Grade pour Fashion (horizontale)
  geom_hline(yintercept = avg_fashion, color = "red", linetype = "solid", linewidth = 1) +
  
  # FIX : Définir l'échelle de 0 à 20 pour les deux axes
  scale_x_continuous(limits = c(0, 20), breaks = seq(0, 20, 5)) +
  scale_y_continuous(limits = c(0, 20), breaks = seq(0, 20, 5)) +
  
  labs(
    title = "Relation entre les Notes Moyennes : Fashion Design vs. Cryptography",
    subtitle = paste("Moyenne Crypto et Fashion (Ligne Rouge) :", round(avg_crypto, 2), " | ", round(avg_fashion, 2)),
    x = "Moyenne des Notes en Cryptography and Codebreaking (sur 20)",
    y = "Moyenne des Notes en Fashion Design and Textile Innovation (sur 20)"
  ) +
  theme_minimal(base_size = 14)
```
In this graph we have one colour per group and mainly we can see that the mean fro the course in cryptography and codebreaking is lower than the mean in Fashion design and textile innovation. 

### Question 21 
```{r}
# Utilisation de .by pour calculer la corrélation au sein de chaque groupe
correlation_by_group <- student_performance_wide |>
  summarise(
    correlation = cor(
      `Etiquette and Social Graces`,
      `Historical Archaeology and Antiquarian Studies`,
      use = "complete.obs" # Gérer les NA si des étudiants n'ont aucune note dans un cours
    ),
    .by = group
  ) |>
  arrange(desc(abs(correlation))) # Trier par valeur absolue pour identifier les plus corrélés

correlation_by_group |>
  kable(
    caption = "Corrélation entre les Notes Moyennes de deux cours, Groupe par Groupe",
    digits = 3
  )
```
In every groups there is a positive correlation between the grades in Historical Archaeology and Antiquarian Studies. However in some groupe the correlation is more important for instnace in group 16 there is an important correlation while in group 5 there is not. 

### Question 22 
```{r}
# 1. Identifier le groupe avec la corrélation absolue la plus élevée (le premier de la table triée)
most_correlated_group <- correlation_by_group |>
  slice_head(n = 1) |>
  pull(group)

# 2. Filtrer le data frame pour ce groupe uniquement
data_most_correlated <- student_performance_wide |>
  filter(group == most_correlated_group)

# 3. Créer le graphique
ggplot(data_most_correlated, aes(x = `Historical Archaeology and Antiquarian Studies`, y = `Etiquette and Social Graces`)) +
  geom_point(alpha = 0.8, color = "#CC6677") +
  geom_smooth(method = "lm", se = FALSE, color = "darkred") +
  labs(
    title = paste("Notes Moyennes : Etiquette vs. Archaeology (Groupe", most_correlated_group, ")"),
    subtitle = paste("Corrélation =", round(correlation_by_group$correlation[1], 3)),
    x = "Moyenne des Notes en Historical Archaeology and Antiquarian Studies",
    y = "Moyenne des Notes en Etiquette and Social Graces"
  ) +
  theme_minimal(base_size = 14)
```
In this group we can see a clear correlation between the grade obtain in Historical Archeology and in Etiquette and social graces. The higher the grade in one course is the higher it is in the other course. 

### Question 23 
```{r}
library(dplyr)
library(tidyr)
library(knitr)

# Correction du code pour la Question 23
student_final_grades <- student_performance_wide |>
  # 1. Utiliser rowwise() pour que les opérations (comme mean) s'appliquent LIGNE par LIGNE.
  rowwise() |> 
  mutate(
    final_grade = mean(c_across(3:ncol(student_performance_wide)), na.rm = TRUE)
  ) |>
  ungroup() |>
  left_join(students |> select(id, sex), by = "id") |>
  select(id, group, sex, final_grade) |>
  arrange(desc(final_grade))

# 2. Afficher les 5 premières lignes
student_final_grades |>
  slice_head(n = 5) |>
  kable(
    caption = "Top 5 des Étudiants par Note Finale",
    digits = 2
  )
```
### Question 24 
Let's do a boxplot since it gives à good idea of the distribution of grades per group. 
```{r}
ggplot(student_final_grades, aes(x = as.factor(group), y = final_grade, fill = as.factor(group))) +
  geom_boxplot() +
  labs(
    title = "Distribution de la Note Finale par Groupe d'Étudiants",
    x = "Groupe",
    y = "Note Finale (Moyenne des Moyennes de Cours)"
  ) +
  scale_y_continuous(limits = c(0, 20)) + # Plafonner l'axe Y à 20
  theme_minimal(base_size = 14) +
  theme(legend.position = "none")
```
Here we can note that the average is similar between groups. 

```{r}
library(ggplot2)
library(dplyr)

# 1. Calculer la note finale moyenne par groupe et par sexe
mean_final_grade_by_group_sex <- student_final_grades |>
  summarise(
    avg_final_grade = mean(final_grade, na.rm = TRUE),
    .by = c(group, sex) # Utilisation efficace de .by
  ) |>
  # Trier par groupe pour la cohérence
  arrange(group)

# 2. Créer le graphique de dispersion des moyennes
ggplot(mean_final_grade_by_group_sex, aes(x = as.factor(group), y = avg_final_grade, color = sex, group = sex)) +
  
  # Points pour les moyennes
  geom_point(size = 3) +
  
  # Lignes reliant les moyennes pour chaque sexe (facilite la lecture de l'évolution)
  geom_line(linewidth = 1) +
  
  # Lignes pointillées pour la moyenne générale des notes finales pour référence
  geom_hline(yintercept = mean(student_final_grades$final_grade, na.rm = TRUE), 
             linetype = "dashed", color = "darkgrey", linewidth = 1) +
  
  labs(
    title = "Note Finale Moyenne par Groupe et par Sexe",
    subtitle = "La ligne pointillée montre la moyenne générale de tous les étudiants.",
    x = "Groupe d'Étudiants",
    y = "Moyenne de la Note Finale",
    color = "Sexe"
  ) +
  scale_y_continuous(limits = c(0, 20)) +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```



## Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

```{r}
1 + 1
```

You can add options to executable code like this

```{r}
#| echo: false
2 * 2
```

The `echo: false` option disables the printing of code (only output is displayed).
